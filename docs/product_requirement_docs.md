# **任务管理平台 API 需求规格说明书 (SRS)**

* **文档版本**: 1.0
* **创建日期**: 2025年7月10日
* **项目名称**: 后台任务管理平台 API

## 1. 引言

### 1.1. 项目背景
为了高效、可靠地处理一系列后台任务，本项目旨在开发一个任务管理平台的后端API。该平台将负责任务的接收、存储、状态跟踪、优先级调度以及在出现故障时的智能重试。

### 1.2. 文档目的
本需求规格说明书（SRS）详细描述了任务管理平台API的功能性需求和非功能性需求，旨在为后续的系统设计、开发、测试和验收提供明确的依据和标准。

## 2. 系统定位与用户画像

### 2.1. 系统定位
一个**单用户**的后台任务处理系统。系统的主要交互对象是其他应用程序、服务或自动化脚本（即“客户端”），而非人类用户通过图形界面直接操作。

### 2.2. 用户画像
API的调用方（客户端）负责提交需要处理的任务，并查询任务的执行状态和结果。客户端不直接参与或干预任务生命周期的具体流转。

## 3. 功能性需求

### 3.1. 核心实体：任务 (Task)
系统核心的数据实体是“任务”，其数据模型（对应数据库表）应包含以下属性：

| 字段名 (Field) | 数据类型 (Type) | 描述 (Description) | 备注 (Notes) |
| --- | --- | --- | --- |
| `id` | Integer | 任务的唯一标识符 | 主键，自动递增 |
| `title` | String | 任务的简短标题/名称 | 必需 |
| `description` | Text | 任务的详细描述 | 可选 |
| `status` | String | 任务的当前状态 | 参见 3.2 节，必需 |
| `priority` | String | 任务的优先级 | "高", "中", "低"，必需 |
| `tags` | N/A | 任务关联的标签 | 通过中间表实现多对多关系 |
| `due_date` | DateTime | 任务的期望截止日期 | 可选 |
| `timeout_seconds` | Integer | 任务执行的超时时间（秒） | 用于触发智能重试 |
| `retry_limit` | Integer | 最大重试次数 | |
| `current_retry_count` | Integer | 当前已重试的次数 | 默认值为 0 |
| `created_at` | DateTime | 记录创建时间 | 系统自动生成 |
| `updated_at` | DateTime | 记录最后更新时间 | 系统自动更新 |
| `completed_at` | DateTime | 任务实际完成的时间 | 任务成功时记录 |

### 3.2. 任务状态管理 (State Management)
任务状态由系统内部业务逻辑自动驱动，不提供API给客户端直接修改。

#### 3.2.1. 状态定义
* `to_do`: **待办** - 任务被创建后的初始状态。
* `in_progress`: **进行中** - 任务已被工作进程（Worker）获取并开始执行。
* `done`: **已完成** - 任务成功执行完毕。
* `paused`: **暂停** - 任务被暂停执行（此为保留状态，可供未来扩展）。
* `retrying`: **重试中** - 任务因执行超时或失败，正在等待下一次重试。
* `failed`: **失败** - 任务在达到最大重试次数后，仍未能成功执行。
* `cancelled`: **已取消** - 任务被人为或通过管理逻辑取消。

#### 3.2.2. 状态流转图（简述）
1.  客户端**创建**任务 -> 状态为 `to_do`。
2.  工作进程从队列中**获取**任务 -> 状态变为 `in_progress`。
3.  任务执行**超时**且重试次数未满 -> 状态变为 `retrying`，`current_retry_count` 加 1，任务重新入队。
4.  任务执行**超时**且重试次数已满 -> 状态变为 `failed`。
5.  任务执行**成功** -> 状态变为 `done`，记录 `completed_at`。

### 3.3. 智能重试机制 (Smart Retry Mechanism)
* **触发条件**: 处于 `in_progress` 状态的任务，其实际执行时间超过了该任务设定的 `timeout_seconds` 值。
* **重试逻辑**: 系统捕获到超时事件后，将自动执行 3.2.2 中描述的状态流转逻辑，直到任务成功或达到 `retry_limit` 上限。

### 3.4. 任务分类与优先级
* **分类标签 (Tags)**:
    * 采用**多对多**关系模型。系统需包含 `tasks`, `tags`, `task_tags` 三张表。
    * 一个任务可以关联多个标签，一个标签也可以被应用于多个任务。
    * 支持在创建/更新任务时动态关联或创建标签。
* **优先级 (Priority)**:
    * 采用**文本标签**（"高", "中", "低"）进行定义，方便客户端理解。
    * 优先级主要用于任务的获取逻辑，高优先级的任务应被优先处理。

### 3.5. API 接口定义 (Endpoints)
API 应遵循 RESTful 设计风格。

* `POST /tasks`
    * **功能**: 创建一个新任务。
    * **请求体**: 包含 `title`, `description`, `priority`, `tags`, `timeout_seconds`, `retry_limit` 等任务元数据。
    * **成功响应**: `201 Created`，返回创建成功的任务对象的完整信息。
* `GET /tasks`
    * **功能**: 查询任务列表，支持复合查询。
    * **查询参数**:
        * `status` (e.g., `to_do`)
        * `priority` (e.g., `高`)
        * `tag` (e.g., `核心业务`)
    * **成功响应**: `200 OK`，返回符合条件的任务对象数组。
* `GET /tasks/{task_id}`
    * **功能**: 获取指定ID的单个任务的详细信息。
    * **成功响应**: `200 OK`，返回该任务对象。
    * **失败响应**: `404 Not Found`。
* `PATCH /tasks/{task_id}`
    * **功能**: 更新一个已存在任务的元数据。
    * **请求体**: 包含需要修改的字段，如 `title`, `priority`, `tags` 等。**禁止**通过此接口修改 `status`。
    * **成功响应**: `200 OK`，返回更新后的任务对象。
* `DELETE /tasks/{task_id}`
    * **功能**: 删除一个任务。
    * **成功响应**: `204 No Content`。

## 4. 非功能性需求

### 4.1. 技术栈
* **Web 框架**: FastAPI
* **ORM**: SQLAlchemy
* **主数据库**: MySQL
* **缓存/会话**: Redis (可用于实现任务队列或分布式锁)
* **数据库迁移**: Alembic
* **ASGI 服务器**: Uvicorn

### 4.2. 性能
* API 应保证低延迟和高吞吐量，充分利用 FastAPI 的异步特性。
* 对于频繁查询的接口，应考虑使用 Redis 进行缓存，降低数据库压力。

### 4.3. 可靠性
* 系统应保证任务状态的最终一致性。
* 数据库操作应具有事务性，保证数据完整。

### 4.4. 可维护性
* 代码结构应清晰，遵循模块化设计。
* 使用 Alembic 管理数据库结构变更，保证开发与部署环境的一致性。
* API 应提供完善的文档（可由 FastAPI 自动生成）。
